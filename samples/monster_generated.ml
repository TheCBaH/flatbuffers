(* automatically generated by the FlatBuffers compiler, do not modify *)

open FlatBuffers

module MyGame = struct

module Sample = struct

module Weapon = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    let getRootAsWeapon b =
        let offset = (ByteBuffer.read_ocaml_int32 b (ByteBuffer.position b)) + (ByteBuffer.position b) in
        init b offset

    (* Weapon *)
    let name (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 4 in
        if(offset!=0) then Some (ByteBuffer.__string t.ByteBuffer.b (t.ByteBuffer.pos + offset))
        else None

    (* Weapon *)
    let damage (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 6 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt16 t.ByteBuffer.b offset
        else 0

    let start builder =
        Builder.startObject  builder 2

    let addName builder name =
        Builder.addFieldOffset builder 0 name (0)

    let addDamage builder damage =
        Builder.addFieldInt16 builder 1 damage (0)

    let end_ builder =
        Builder.endObject builder

    let create builder name damage =
        start builder;
        addName builder name;
        addDamage builder damage;
        end_ builder
end

module Vec3 = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    (* Vec3 *)
    let x (t:offset) =
        let offset = t.ByteBuffer.pos + 0 in
        ByteBuffer.readFloat32 t.ByteBuffer.b offset

    (* Vec3 *)
    let y (t:offset) =
        let offset = t.ByteBuffer.pos + 4 in
        ByteBuffer.readFloat32 t.ByteBuffer.b offset

    (* Vec3 *)
    let z (t:offset) =
        let offset = t.ByteBuffer.pos + 8 in
        ByteBuffer.readFloat32 t.ByteBuffer.b offset


    let createVec3 builder ~x ~y ~z =
        Builder.prep builder ~additional_bytes:4 12;
        Builder.addFloat32 builder z;
        Builder.addFloat32 builder y;
        Builder.addFloat32 builder x;
        Builder.offset builder
end

module Equipment = struct
     type t =
        | NONE
        | Weapon

    let of_int = function
        | 0 -> NONE
        | 1 -> Weapon
        | _ -> failwith "Invalid value"

    let to_int = function
        | NONE -> 0
        | Weapon -> 1

end

module Color = struct
     type t =
        | Red
        | Green
        | Blue

    let of_int = function
        | 0 -> Red
        | 1 -> Green
        | 2 -> Blue
        | _ -> failwith "Invalid value"

    let to_int = function
        | Red -> 0
        | Green -> 1
        | Blue -> 2

end

module Monster = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    let getRootAsMonster b =
        let offset = (ByteBuffer.read_ocaml_int32 b (ByteBuffer.position b)) + (ByteBuffer.position b) in
        init b offset

    (* Monster *)
    let pos (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 4 in
        if(offset!=0) then Some (let offset = t.ByteBuffer.pos + offset in Vec3.init t.ByteBuffer.b offset)
        else None

    (* Monster *)
    let mana (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 6 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt16 t.ByteBuffer.b offset
        else 150

    (* Monster *)
    let hp (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 8 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt16 t.ByteBuffer.b offset
        else 100

    (* Monster *)
    let name (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 10 in
        if(offset!=0) then Some (ByteBuffer.__string t.ByteBuffer.b (t.ByteBuffer.pos + offset))
        else None

    let inventoryLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 14 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let inventory (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 14 in
        if(offset!=0) then
            let index = index in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readUint8 t.ByteBuffer.b offset
        else 0

    (* Monster *)
    let color (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 16 in
        if(offset!=0) then Color.of_int (let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt8 t.ByteBuffer.b offset)
        else Color.Blue

    let weaponsLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 18 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let weapons (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 18 in
        if(offset!=0) then
            let index = index * 4 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.ByteBuffer.b offset in
            Some (Weapon.init t.ByteBuffer.b offset)
        else None

    (* Monster *)
    let equipped_type (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 20 in
        if(offset!=0) then Equipment.of_int (let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint8 t.ByteBuffer.b offset)
        else Equipment.NONE

    (* Monster *)
    let equipped (t:offset) =
        ByteBuffer.__union t 22

    let pathLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 24 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let path (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 24 in
        if(offset!=0) then
            let index = index * 12 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.ByteBuffer.b offset in
            Some (Vec3.init t.ByteBuffer.b offset)
        else None

    let start builder =
        Builder.startObject  builder 11

    let addPos builder pos =
        Builder.addFieldOffset builder 0 pos (0)

    let addMana builder mana =
        Builder.addFieldInt16 builder 1 mana (150)

    let addHp builder hp =
        Builder.addFieldInt16 builder 2 hp (100)

    let addName builder name =
        Builder.addFieldOffset builder 3 name (0)

    let addInventory builder inventory =
        Builder.addFieldOffset builder 5 inventory (0)

    let startMonsterInventory builder numElems =
        Builder.startVector builder 1 numElems 1

    let addColor builder color =
        Builder.addFieldInt8 builder 6 color (2)

    let addWeapons builder weapons =
        Builder.addFieldOffset builder 7 weapons (0)

    let startMonsterWeapons builder numElems =
        Builder.startVector builder 4 numElems 4

    let addEquippedType builder equippedType =
        Builder.addFieldUint8 builder 8 equippedType (0)

    let addEquipped builder equipped =
        Builder.addFieldOffset builder 9 equipped (0)

    let addPath builder path =
        Builder.addFieldOffset builder 10 path (0)

    let startMonsterPath builder numElems =
        Builder.startVector builder 12 numElems 4

    let end_ builder =
        Builder.endObject builder

    let create builder pos mana hp name inventory color weapons equippedType equipped path =
        start builder;
        addPos builder pos;
        addMana builder mana;
        addHp builder hp;
        addName builder name;
        addInventory builder inventory;
        addColor builder color;
        addWeapons builder weapons;
        addEquippedType builder equippedType;
        addEquipped builder equipped;
        addPath builder path;
        end_ builder
end

end (* Sample *)
end (* MyGame *)

(* automatically generated by the FlatBuffers compiler, do not modify *)

open FlatBuffers

module MyGame = struct

module InParentNamespace = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    let getRootAsInParentNamespace b =
        let offset = (ByteBuffer.read_ocaml_int32 b (ByteBuffer.position b)) + (ByteBuffer.position b) in
        init b offset

    let start builder =
        Builder.startObject  builder 0

    let end_ builder =
        Builder.endObject builder


    let create ~builder=
        start builder;
        end_ builder
end

module Example = struct

module TypeAliases = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    let getRootAsTypeAliases b =
        let offset = (ByteBuffer.read_ocaml_int32 b (ByteBuffer.position b)) + (ByteBuffer.position b) in
        init b offset

    (* TypeAliases *)
    let i8 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 4 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt8 t.ByteBuffer.b offset
        else 0

    (* TypeAliases *)
    let u8 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 6 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint8 t.ByteBuffer.b offset
        else 0

    (* TypeAliases *)
    let i16 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 8 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt16 t.ByteBuffer.b offset
        else 0

    (* TypeAliases *)
    let u16 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 10 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint16 t.ByteBuffer.b offset
        else 0

    (* TypeAliases *)
    let i32 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 12 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt32 t.ByteBuffer.b offset
        else Int32.zero

    (* TypeAliases *)
    let u32 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 14 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint32 t.ByteBuffer.b offset
        else Int64.zero

    (* TypeAliases *)
    let i64 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 16 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt64 t.ByteBuffer.b offset
        else Int64.zero

    (* TypeAliases *)
    let u64 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 18 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint64 t.ByteBuffer.b offset
        else Int64.zero

    (* TypeAliases *)
    let f32 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 20 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readFloat32 t.ByteBuffer.b offset
        else 0.0

    (* TypeAliases *)
    let f64 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 22 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readFloat64 t.ByteBuffer.b offset
        else 0.0

    let v8Length (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 24 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let v8 (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 24 in
        if(offset!=0) then
            let index = index in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readInt8 t.ByteBuffer.b offset
        else 0

    let vf64Length (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 26 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let vf64 (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 26 in
        if(offset!=0) then
            let index = index * 8 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readFloat64 t.ByteBuffer.b offset
        else 0.0

    let start builder =
        Builder.startObject  builder 12

    let addI8 builder i8 =
        Builder.addFieldInt8 builder 0 i8 (0)

    let addU8 builder u8 =
        Builder.addFieldUint8 builder 1 u8 (0)

    let addI16 builder i16 =
        Builder.addFieldInt16 builder 2 i16 (0)

    let addU16 builder u16 =
        Builder.addFieldUint16 builder 3 u16 (0)

    let addI32 builder i32 =
        Builder.addFieldInt32 builder 4 i32 (Int32.zero)

    let addU32 builder u32 =
        Builder.addFieldUint32 builder 5 u32 (Int64.zero)

    let addI64 builder i64 =
        Builder.addFieldInt64 builder 6 i64 (Int64.zero)

    let addU64 builder u64 =
        Builder.addFieldUint64 builder 7 u64 (Int64.zero)

    let addF32 builder f32 =
        Builder.addFieldFloat32 builder 8 f32 (0.0)

    let addF64 builder f64 =
        Builder.addFieldFloat64 builder 9 f64 (0.0)

    let addV8 builder v8 =
        Builder.addFieldOffset builder 10 v8 (0)

    let startTypeAliasesV8 builder numElems =
        Builder.startVector builder 1 numElems 1

    let addVf64 builder vf64 =
        Builder.addFieldOffset builder 11 vf64 (0)

    let startTypeAliasesVf64 builder numElems =
        Builder.startVector builder 8 numElems 8

    let end_ builder =
        Builder.endObject builder


    let create ~builder~i8 ~u8 ~i16 ~u16 ~i32 ~u32 ~i64 ~u64 ~f32 ~f64 ~v8 ~vf64 =
        start builder;
        addI8 builder i8;
        addU8 builder u8;
        addI16 builder i16;
        addU16 builder u16;
        addI32 builder i32;
        addU32 builder u32;
        addI64 builder i64;
        addU64 builder u64;
        addF32 builder f32;
        addF64 builder f64;
        addV8 builder v8;
        addVf64 builder vf64;
        end_ builder
end

(*  Composite components of Monster color.*)
module Color = struct
     type t =
        | Red
(*
 \brief color Green
 Green is bit_flag with value (1u << 1)

*)
        | Green
(*  \brief color Blue (1u << 3)*)
        | Blue

    let of_int = function
        | 1 -> Red
        | 2 -> Green
        | 8 -> Blue
        | _ -> failwith "Invalid value"

    let to_int = function
        | Red -> 1
        | Green -> 2
        | Blue -> 8

end

module Race = struct
     type t =
        | None
        | Human
        | Dwarf
        | Elf

    let of_int = function
        | -1 -> None
        | 0 -> Human
        | 1 -> Dwarf
        | 2 -> Elf
        | _ -> failwith "Invalid value"

    let to_int = function
        | None -> -1
        | Human -> 0
        | Dwarf -> 1
        | Elf -> 2

end

module Ability = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    (* Ability *)
    let id (t:offset) =
        let offset = t.ByteBuffer.pos + 0 in
        ByteBuffer.readUint32 t.ByteBuffer.b offset

    (* Ability *)
    let distance (t:offset) =
        let offset = t.ByteBuffer.pos + 4 in
        ByteBuffer.readUint32 t.ByteBuffer.b offset


    let create ~builder ~id ~distance =
        Builder.prep builder ~additional_bytes:4 8;
        Builder.addUint32 builder distance;
        Builder.addUint32 builder id;
        Builder.offset builder
end

module Stat = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    let getRootAsStat b =
        let offset = (ByteBuffer.read_ocaml_int32 b (ByteBuffer.position b)) + (ByteBuffer.position b) in
        init b offset

    (* Stat *)
    let id (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 4 in
        if(offset!=0) then Some (ByteBuffer.__string t.ByteBuffer.b (t.ByteBuffer.pos + offset))
        else None

    (* Stat *)
    let val_ (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 6 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt64 t.ByteBuffer.b offset
        else Int64.zero

    (* Stat *)
    let count (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 8 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint16 t.ByteBuffer.b offset
        else 0

    let start builder =
        Builder.startObject  builder 3

    let addId builder id =
        Builder.addFieldOffset builder 0 id (0)

    let addVal_ builder val_ =
        Builder.addFieldInt64 builder 1 val_ (Int64.zero)

    let addCount builder count =
        Builder.addFieldUint16 builder 2 count (0)

    let end_ builder =
        Builder.endObject builder


    let create ~builder~id ~val_ ~count =
        start builder;
        addId builder id;
        addVal_ builder val_;
        addCount builder count;
        end_ builder
end

module Referrable = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    let getRootAsReferrable b =
        let offset = (ByteBuffer.read_ocaml_int32 b (ByteBuffer.position b)) + (ByteBuffer.position b) in
        init b offset

    (* Referrable *)
    let id (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 4 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint64 t.ByteBuffer.b offset
        else Int64.zero

    let start builder =
        Builder.startObject  builder 1

    let addId builder id =
        Builder.addFieldUint64 builder 0 id (Int64.zero)

    let end_ builder =
        Builder.endObject builder


    let create ~builder~id =
        start builder;
        addId builder id;
        end_ builder
end

module Any = struct
     type t =
        | NONE
        | Monster
        | TestSimpleTableWithEnum
        | MyGame_Example2_Monster

    let of_int = function
        | 0 -> NONE
        | 1 -> Monster
        | 2 -> TestSimpleTableWithEnum
        | 3 -> MyGame_Example2_Monster
        | _ -> failwith "Invalid value"

    let to_int = function
        | NONE -> 0
        | Monster -> 1
        | TestSimpleTableWithEnum -> 2
        | MyGame_Example2_Monster -> 3

end

module AnyUniqueAliases = struct
     type t =
        | NONE
        | M
        | TS
        | M2

    let of_int = function
        | 0 -> NONE
        | 1 -> M
        | 2 -> TS
        | 3 -> M2
        | _ -> failwith "Invalid value"

    let to_int = function
        | NONE -> 0
        | M -> 1
        | TS -> 2
        | M2 -> 3

end

module Test = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    (* Test *)
    let a (t:offset) =
        let offset = t.ByteBuffer.pos + 0 in
        ByteBuffer.readInt16 t.ByteBuffer.b offset

    (* Test *)
    let b (t:offset) =
        let offset = t.ByteBuffer.pos + 2 in
        ByteBuffer.readInt8 t.ByteBuffer.b offset


    let create ~builder ~a ~b =
        Builder.prep builder ~additional_bytes:2 4;
        Builder.pad builder 1;
        Builder.addInt8 builder b;
        Builder.addInt16 builder a;
        Builder.offset builder
end

module AnyAmbiguousAliases = struct
     type t =
        | NONE
        | M1
        | M2
        | M3

    let of_int = function
        | 0 -> NONE
        | 1 -> M1
        | 2 -> M2
        | 3 -> M3
        | _ -> failwith "Invalid value"

    let to_int = function
        | NONE -> 0
        | M1 -> 1
        | M2 -> 2
        | M3 -> 3

end

module TestSimpleTableWithEnum = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    let getRootAsTestSimpleTableWithEnum b =
        let offset = (ByteBuffer.read_ocaml_int32 b (ByteBuffer.position b)) + (ByteBuffer.position b) in
        init b offset

    (* TestSimpleTableWithEnum *)
    let color (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 4 in
        if(offset!=0) then Color.of_int (let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint8 t.ByteBuffer.b offset)
        else Color.Green

    let start builder =
        Builder.startObject  builder 1

    let addColor builder color =
        Builder.addFieldUint8 builder 0 color (2)

    let end_ builder =
        Builder.endObject builder


    let create ~builder~color =
        start builder;
        addColor builder color;
        end_ builder
end

module StructOfStructs = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    (* StructOfStructs *)
    let a (t:offset) =
        let offset = t.ByteBuffer.pos + 0 in
        Ability.init t.ByteBuffer.b offset

    (* StructOfStructs *)
    let b (t:offset) =
        let offset = t.ByteBuffer.pos + 8 in
        Test.init t.ByteBuffer.b offset

    (* StructOfStructs *)
    let c (t:offset) =
        let offset = t.ByteBuffer.pos + 12 in
        Ability.init t.ByteBuffer.b offset


    let create ~builder ~a_id ~a_distance ~b_a ~b_b ~c_id ~c_distance =
        Builder.prep builder ~additional_bytes:4 20;
        Builder.prep builder ~additional_bytes:4 8;
        Builder.addUint32 builder c_distance;
        Builder.addUint32 builder c_id;
        Builder.prep builder ~additional_bytes:2 4;
        Builder.pad builder 1;
        Builder.addInt8 builder b_b;
        Builder.addInt16 builder b_a;
        Builder.prep builder ~additional_bytes:4 8;
        Builder.addUint32 builder a_distance;
        Builder.addUint32 builder a_id;
        Builder.offset builder
end

module Vec3 = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    (* Vec3 *)
    let x (t:offset) =
        let offset = t.ByteBuffer.pos + 0 in
        ByteBuffer.readFloat32 t.ByteBuffer.b offset

    (* Vec3 *)
    let y (t:offset) =
        let offset = t.ByteBuffer.pos + 4 in
        ByteBuffer.readFloat32 t.ByteBuffer.b offset

    (* Vec3 *)
    let z (t:offset) =
        let offset = t.ByteBuffer.pos + 8 in
        ByteBuffer.readFloat32 t.ByteBuffer.b offset

    (* Vec3 *)
    let test1 (t:offset) =
        let offset = t.ByteBuffer.pos + 16 in
        ByteBuffer.readFloat64 t.ByteBuffer.b offset

    (* Vec3 *)
    let test2 (t:offset) =
        let offset = t.ByteBuffer.pos + 24 in
        ByteBuffer.readUint8 t.ByteBuffer.b offset

    (* Vec3 *)
    let test3 (t:offset) =
        let offset = t.ByteBuffer.pos + 26 in
        Test.init t.ByteBuffer.b offset


    let create ~builder ~x ~y ~z ~test1 ~test2 ~test3_a ~test3_b =
        Builder.prep builder ~additional_bytes:8 32;
        Builder.pad builder 2;
        Builder.prep builder ~additional_bytes:2 4;
        Builder.pad builder 1;
        Builder.addInt8 builder test3_b;
        Builder.addInt16 builder test3_a;
        Builder.pad builder 1;
        Builder.addUint8 builder test2;
        Builder.addFloat64 builder test1;
        Builder.pad builder 4;
        Builder.addFloat32 builder z;
        Builder.addFloat32 builder y;
        Builder.addFloat32 builder x;
        Builder.offset builder
end

(*  an example documentation comment: "monster object"*)
module Monster = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    let getRootAsMonster b =
        let offset = (ByteBuffer.read_ocaml_int32 b (ByteBuffer.position b)) + (ByteBuffer.position b) in
        init b offset

    (* Monster *)
    let pos (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 4 in
        if(offset!=0) then Some (let offset = t.ByteBuffer.pos + offset in Vec3.init t.ByteBuffer.b offset)
        else None

    (* Monster *)
    let mana (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 6 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt16 t.ByteBuffer.b offset
        else 150

    (* Monster *)
    let hp (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 8 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt16 t.ByteBuffer.b offset
        else 100

    (* Monster *)
    let name (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 10 in
        if(offset!=0) then Some (ByteBuffer.__string t.ByteBuffer.b (t.ByteBuffer.pos + offset))
        else None

    let inventoryLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 14 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let inventory (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 14 in
        if(offset!=0) then
            let index = index in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readUint8 t.ByteBuffer.b offset
        else 0

    (* Monster *)
    let color (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 16 in
        if(offset!=0) then Color.of_int (let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint8 t.ByteBuffer.b offset)
        else Color.Blue

    (* Monster *)
    let test_type (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 18 in
        if(offset!=0) then Any.of_int (let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint8 t.ByteBuffer.b offset)
        else Any.NONE

    (* Monster *)
    let test (t:offset) =
        ByteBuffer.__union t 20

    let test4Length (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 22 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let test4 (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 22 in
        if(offset!=0) then
            let index = index * 4 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.ByteBuffer.b offset in
            Some (Test.init t.ByteBuffer.b offset)
        else None

    let testarrayofstringLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 24 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let testarrayofstring (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 24 in
        if(offset!=0) then
            let index = index * 4 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            Some (ByteBuffer.__string t.ByteBuffer.b offset)
        else None

(*
 an example documentation comment: this will end up in the generated code
 multiline too

*)
    let testarrayoftablesLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 26 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let testarrayoftables (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 26 in
        if(offset!=0) then
            let index = index * 4 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.ByteBuffer.b offset in
            Some (init t.ByteBuffer.b offset)
        else None

    (* Monster *)
    let enemy (t:offset) =
        let offset = t.ByteBuffer.pos + (ByteBuffer.__indirect t.ByteBuffer.b 28) in
        if(offset!=0) then Some (let offset = t.ByteBuffer.pos + offset in init t.ByteBuffer.b offset)
        else None

    let testnestedflatbufferLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 30 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let testnestedflatbuffer (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 30 in
        if(offset!=0) then
            let index = index in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readUint8 t.ByteBuffer.b offset
        else 0

    (* Monster *)
    let testempty (t:offset) =
        let offset = t.ByteBuffer.pos + (ByteBuffer.__indirect t.ByteBuffer.b 32) in
        if(offset!=0) then Some (let offset = t.ByteBuffer.pos + offset in Stat.init t.ByteBuffer.b offset)
        else None

    (* Monster *)
    let testbool (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 34 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readBool t.ByteBuffer.b offset
        else false

    (* Monster *)
    let testhashs32_fnv1 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 36 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt32 t.ByteBuffer.b offset
        else Int32.zero

    (* Monster *)
    let testhashu32_fnv1 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 38 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint32 t.ByteBuffer.b offset
        else Int64.zero

    (* Monster *)
    let testhashs64_fnv1 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 40 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt64 t.ByteBuffer.b offset
        else Int64.zero

    (* Monster *)
    let testhashu64_fnv1 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 42 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint64 t.ByteBuffer.b offset
        else Int64.zero

    (* Monster *)
    let testhashs32_fnv1a (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 44 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt32 t.ByteBuffer.b offset
        else Int32.zero

    (* Monster *)
    let testhashu32_fnv1a (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 46 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint32 t.ByteBuffer.b offset
        else Int64.zero

    (* Monster *)
    let testhashs64_fnv1a (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 48 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt64 t.ByteBuffer.b offset
        else Int64.zero

    (* Monster *)
    let testhashu64_fnv1a (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 50 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint64 t.ByteBuffer.b offset
        else Int64.zero

    let testarrayofboolsLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 52 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let testarrayofbools (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 52 in
        if(offset!=0) then
            let index = index in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readBool t.ByteBuffer.b offset
        else false

    (* Monster *)
    let testf (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 54 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readFloat32 t.ByteBuffer.b offset
        else 3.14159

    (* Monster *)
    let testf2 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 56 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readFloat32 t.ByteBuffer.b offset
        else 3.0

    (* Monster *)
    let testf3 (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 58 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readFloat32 t.ByteBuffer.b offset
        else 0.0

    let testarrayofstring2Length (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 60 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let testarrayofstring2 (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 60 in
        if(offset!=0) then
            let index = index * 4 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            Some (ByteBuffer.__string t.ByteBuffer.b offset)
        else None

    let testarrayofsortedstructLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 62 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let testarrayofsortedstruct (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 62 in
        if(offset!=0) then
            let index = index * 8 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.ByteBuffer.b offset in
            Some (Ability.init t.ByteBuffer.b offset)
        else None

    let flexLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 64 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let flex (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 64 in
        if(offset!=0) then
            let index = index in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readUint8 t.ByteBuffer.b offset
        else 0

    let test5Length (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 66 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let test5 (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 66 in
        if(offset!=0) then
            let index = index * 4 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.ByteBuffer.b offset in
            Some (Test.init t.ByteBuffer.b offset)
        else None

    let vector_of_longsLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 68 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let vector_of_longs (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 68 in
        if(offset!=0) then
            let index = index * 8 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readInt64 t.ByteBuffer.b offset
        else Int64.zero

    let vector_of_doublesLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 70 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let vector_of_doubles (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 70 in
        if(offset!=0) then
            let index = index * 8 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readFloat64 t.ByteBuffer.b offset
        else 0.0

    (* Monster *)
    let parent_namespace_test (t:offset) =
        let offset = t.ByteBuffer.pos + (ByteBuffer.__indirect t.ByteBuffer.b 72) in
        if(offset!=0) then Some (let offset = t.ByteBuffer.pos + offset in InParentNamespace.init t.ByteBuffer.b offset)
        else None

    let vector_of_referrablesLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 74 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let vector_of_referrables (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 74 in
        if(offset!=0) then
            let index = index * 4 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.ByteBuffer.b offset in
            Some (Referrable.init t.ByteBuffer.b offset)
        else None

    (* Monster *)
    let single_weak_reference (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 76 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint64 t.ByteBuffer.b offset
        else Int64.zero

    let vector_of_weak_referencesLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 78 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let vector_of_weak_references (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 78 in
        if(offset!=0) then
            let index = index * 8 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readUint64 t.ByteBuffer.b offset
        else Int64.zero

    let vector_of_strong_referrablesLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 80 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let vector_of_strong_referrables (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 80 in
        if(offset!=0) then
            let index = index * 4 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.ByteBuffer.b offset in
            Some (Referrable.init t.ByteBuffer.b offset)
        else None

    (* Monster *)
    let co_owning_reference (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 82 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint64 t.ByteBuffer.b offset
        else Int64.zero

    let vector_of_co_owning_referencesLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 84 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let vector_of_co_owning_references (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 84 in
        if(offset!=0) then
            let index = index * 8 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readUint64 t.ByteBuffer.b offset
        else Int64.zero

    (* Monster *)
    let non_owning_reference (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 86 in
        if(offset!=0) then let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint64 t.ByteBuffer.b offset
        else Int64.zero

    let vector_of_non_owning_referencesLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 88 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let vector_of_non_owning_references (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 88 in
        if(offset!=0) then
            let index = index * 8 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readUint64 t.ByteBuffer.b offset
        else Int64.zero

    (* Monster *)
    let any_unique_type (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 90 in
        if(offset!=0) then AnyUniqueAliases.of_int (let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint8 t.ByteBuffer.b offset)
        else AnyUniqueAliases.NONE

    (* Monster *)
    let any_unique (t:offset) =
        ByteBuffer.__union t 92

    (* Monster *)
    let any_ambiguous_type (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 94 in
        if(offset!=0) then AnyAmbiguousAliases.of_int (let offset = t.ByteBuffer.pos + offset in ByteBuffer.readUint8 t.ByteBuffer.b offset)
        else AnyAmbiguousAliases.NONE

    (* Monster *)
    let any_ambiguous (t:offset) =
        ByteBuffer.__union t 96

    let vector_of_enumsLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 98 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let vector_of_enums (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 98 in
        if(offset!=0) then
            let index = index in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readUint8 t.ByteBuffer.b offset
        else 0

    (* Monster *)
    let signed_enum (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 100 in
        if(offset!=0) then Race.of_int (let offset = t.ByteBuffer.pos + offset in ByteBuffer.readInt8 t.ByteBuffer.b offset)
        else Race.None

    let testrequirednestedflatbufferLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 102 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let testrequirednestedflatbuffer (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 102 in
        if(offset!=0) then
            let index = index in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            ByteBuffer.readUint8 t.ByteBuffer.b offset
        else 0

    let scalar_key_sorted_tablesLength (t:offset) =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 104 in
        if(offset!=0) then ByteBuffer.__vector_len t.ByteBuffer.b (t.ByteBuffer.pos + offset)
        else 0

    let scalar_key_sorted_tables (t:offset) index =
        let offset = ByteBuffer.__offset t.ByteBuffer.b t.ByteBuffer.pos 104 in
        if(offset!=0) then
            let index = index * 4 in
            let offset = (ByteBuffer.__vector t.ByteBuffer.b (t.ByteBuffer.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.ByteBuffer.b offset in
            Some (Stat.init t.ByteBuffer.b offset)
        else None

    let start builder =
        Builder.startObject  builder 51

    let addPos builder pos =
        Builder.addFieldOffset builder 0 pos (0)

    let addMana builder mana =
        Builder.addFieldInt16 builder 1 mana (150)

    let addHp builder hp =
        Builder.addFieldInt16 builder 2 hp (100)

    let addName builder name =
        Builder.addFieldOffset builder 3 name (0)

    let addInventory builder inventory =
        Builder.addFieldOffset builder 5 inventory (0)

    let startMonsterInventory builder numElems =
        Builder.startVector builder 1 numElems 1

    let addColor builder color =
        Builder.addFieldUint8 builder 6 color (8)

    let addTestType builder testType =
        Builder.addFieldUint8 builder 7 testType (0)

    let addTest builder test =
        Builder.addFieldOffset builder 8 test (0)

    let addTest4 builder test4 =
        Builder.addFieldOffset builder 9 test4 (0)

    let startMonsterTest4 builder numElems =
        Builder.startVector builder 4 numElems 2

    let addTestarrayofstring builder testarrayofstring =
        Builder.addFieldOffset builder 10 testarrayofstring (0)

    let startMonsterTestarrayofstring builder numElems =
        Builder.startVector builder 4 numElems 4

    let addTestarrayoftables builder testarrayoftables =
        Builder.addFieldOffset builder 11 testarrayoftables (0)

    let startMonsterTestarrayoftables builder numElems =
        Builder.startVector builder 4 numElems 4

    let addEnemy builder enemy =
        Builder.addFieldOffset builder 12 enemy (0)

    let addTestnestedflatbuffer builder testnestedflatbuffer =
        Builder.addFieldOffset builder 13 testnestedflatbuffer (0)

    let startMonsterTestnestedflatbuffer builder numElems =
        Builder.startVector builder 1 numElems 1

    let addTestempty builder testempty =
        Builder.addFieldOffset builder 14 testempty (0)

    let addTestbool builder testbool =
        Builder.addFieldBool builder 15 testbool (false)

    let addTesthashs32Fnv1 builder testhashs32Fnv1 =
        Builder.addFieldInt32 builder 16 testhashs32Fnv1 (Int32.zero)

    let addTesthashu32Fnv1 builder testhashu32Fnv1 =
        Builder.addFieldUint32 builder 17 testhashu32Fnv1 (Int64.zero)

    let addTesthashs64Fnv1 builder testhashs64Fnv1 =
        Builder.addFieldInt64 builder 18 testhashs64Fnv1 (Int64.zero)

    let addTesthashu64Fnv1 builder testhashu64Fnv1 =
        Builder.addFieldUint64 builder 19 testhashu64Fnv1 (Int64.zero)

    let addTesthashs32Fnv1a builder testhashs32Fnv1a =
        Builder.addFieldInt32 builder 20 testhashs32Fnv1a (Int32.zero)

    let addTesthashu32Fnv1a builder testhashu32Fnv1a =
        Builder.addFieldUint32 builder 21 testhashu32Fnv1a (Int64.zero)

    let addTesthashs64Fnv1a builder testhashs64Fnv1a =
        Builder.addFieldInt64 builder 22 testhashs64Fnv1a (Int64.zero)

    let addTesthashu64Fnv1a builder testhashu64Fnv1a =
        Builder.addFieldUint64 builder 23 testhashu64Fnv1a (Int64.zero)

    let addTestarrayofbools builder testarrayofbools =
        Builder.addFieldOffset builder 24 testarrayofbools (0)

    let startMonsterTestarrayofbools builder numElems =
        Builder.startVector builder 1 numElems 1

    let addTestf builder testf =
        Builder.addFieldFloat32 builder 25 testf (3.14159)

    let addTestf2 builder testf2 =
        Builder.addFieldFloat32 builder 26 testf2 (3.0)

    let addTestf3 builder testf3 =
        Builder.addFieldFloat32 builder 27 testf3 (0.0)

    let addTestarrayofstring2 builder testarrayofstring2 =
        Builder.addFieldOffset builder 28 testarrayofstring2 (0)

    let startMonsterTestarrayofstring2 builder numElems =
        Builder.startVector builder 4 numElems 4

    let addTestarrayofsortedstruct builder testarrayofsortedstruct =
        Builder.addFieldOffset builder 29 testarrayofsortedstruct (0)

    let startMonsterTestarrayofsortedstruct builder numElems =
        Builder.startVector builder 8 numElems 4

    let addFlex builder flex =
        Builder.addFieldOffset builder 30 flex (0)

    let startMonsterFlex builder numElems =
        Builder.startVector builder 1 numElems 1

    let addTest5 builder test5 =
        Builder.addFieldOffset builder 31 test5 (0)

    let startMonsterTest5 builder numElems =
        Builder.startVector builder 4 numElems 2

    let addVectorOfLongs builder vectorOfLongs =
        Builder.addFieldOffset builder 32 vectorOfLongs (0)

    let startMonsterVectorOfLongs builder numElems =
        Builder.startVector builder 8 numElems 8

    let addVectorOfDoubles builder vectorOfDoubles =
        Builder.addFieldOffset builder 33 vectorOfDoubles (0)

    let startMonsterVectorOfDoubles builder numElems =
        Builder.startVector builder 8 numElems 8

    let addParentNamespaceTest builder parentNamespaceTest =
        Builder.addFieldOffset builder 34 parentNamespaceTest (0)

    let addVectorOfReferrables builder vectorOfReferrables =
        Builder.addFieldOffset builder 35 vectorOfReferrables (0)

    let startMonsterVectorOfReferrables builder numElems =
        Builder.startVector builder 4 numElems 4

    let addSingleWeakReference builder singleWeakReference =
        Builder.addFieldUint64 builder 36 singleWeakReference (Int64.zero)

    let addVectorOfWeakReferences builder vectorOfWeakReferences =
        Builder.addFieldOffset builder 37 vectorOfWeakReferences (0)

    let startMonsterVectorOfWeakReferences builder numElems =
        Builder.startVector builder 8 numElems 8

    let addVectorOfStrongReferrables builder vectorOfStrongReferrables =
        Builder.addFieldOffset builder 38 vectorOfStrongReferrables (0)

    let startMonsterVectorOfStrongReferrables builder numElems =
        Builder.startVector builder 4 numElems 4

    let addCoOwningReference builder coOwningReference =
        Builder.addFieldUint64 builder 39 coOwningReference (Int64.zero)

    let addVectorOfCoOwningReferences builder vectorOfCoOwningReferences =
        Builder.addFieldOffset builder 40 vectorOfCoOwningReferences (0)

    let startMonsterVectorOfCoOwningReferences builder numElems =
        Builder.startVector builder 8 numElems 8

    let addNonOwningReference builder nonOwningReference =
        Builder.addFieldUint64 builder 41 nonOwningReference (Int64.zero)

    let addVectorOfNonOwningReferences builder vectorOfNonOwningReferences =
        Builder.addFieldOffset builder 42 vectorOfNonOwningReferences (0)

    let startMonsterVectorOfNonOwningReferences builder numElems =
        Builder.startVector builder 8 numElems 8

    let addAnyUniqueType builder anyUniqueType =
        Builder.addFieldUint8 builder 43 anyUniqueType (0)

    let addAnyUnique builder anyUnique =
        Builder.addFieldOffset builder 44 anyUnique (0)

    let addAnyAmbiguousType builder anyAmbiguousType =
        Builder.addFieldUint8 builder 45 anyAmbiguousType (0)

    let addAnyAmbiguous builder anyAmbiguous =
        Builder.addFieldOffset builder 46 anyAmbiguous (0)

    let addVectorOfEnums builder vectorOfEnums =
        Builder.addFieldOffset builder 47 vectorOfEnums (0)

    let startMonsterVectorOfEnums builder numElems =
        Builder.startVector builder 1 numElems 1

    let addSignedEnum builder signedEnum =
        Builder.addFieldInt8 builder 48 signedEnum (-1)

    let addTestrequirednestedflatbuffer builder testrequirednestedflatbuffer =
        Builder.addFieldOffset builder 49 testrequirednestedflatbuffer (0)

    let startMonsterTestrequirednestedflatbuffer builder numElems =
        Builder.startVector builder 1 numElems 1

    let addScalarKeySortedTables builder scalarKeySortedTables =
        Builder.addFieldOffset builder 50 scalarKeySortedTables (0)

    let startMonsterScalarKeySortedTables builder numElems =
        Builder.startVector builder 4 numElems 4

    let end_ builder =
        Builder.endObject builder


    let create ~builder~pos ~mana ~hp ~name ~inventory ~color ~testType ~test ~test4 ~testarrayofstring ~testarrayoftables ~enemy ~testnestedflatbuffer ~testempty ~testbool ~testhashs32Fnv1 ~testhashu32Fnv1 ~testhashs64Fnv1 ~testhashu64Fnv1 ~testhashs32Fnv1a ~testhashu32Fnv1a ~testhashs64Fnv1a ~testhashu64Fnv1a ~testarrayofbools ~testf ~testf2 ~testf3 ~testarrayofstring2 ~testarrayofsortedstruct ~flex ~test5 ~vectorOfLongs ~vectorOfDoubles ~parentNamespaceTest ~vectorOfReferrables ~singleWeakReference ~vectorOfWeakReferences ~vectorOfStrongReferrables ~coOwningReference ~vectorOfCoOwningReferences ~nonOwningReference ~vectorOfNonOwningReferences ~anyUniqueType ~anyUnique ~anyAmbiguousType ~anyAmbiguous ~vectorOfEnums ~signedEnum ~testrequirednestedflatbuffer ~scalarKeySortedTables =
        start builder;
        addPos builder pos;
        addMana builder mana;
        addHp builder hp;
        addName builder name;
        addInventory builder inventory;
        addColor builder color;
        addTestType builder testType;
        addTest builder test;
        addTest4 builder test4;
        addTestarrayofstring builder testarrayofstring;
        addTestarrayoftables builder testarrayoftables;
        addEnemy builder enemy;
        addTestnestedflatbuffer builder testnestedflatbuffer;
        addTestempty builder testempty;
        addTestbool builder testbool;
        addTesthashs32Fnv1 builder testhashs32Fnv1;
        addTesthashu32Fnv1 builder testhashu32Fnv1;
        addTesthashs64Fnv1 builder testhashs64Fnv1;
        addTesthashu64Fnv1 builder testhashu64Fnv1;
        addTesthashs32Fnv1a builder testhashs32Fnv1a;
        addTesthashu32Fnv1a builder testhashu32Fnv1a;
        addTesthashs64Fnv1a builder testhashs64Fnv1a;
        addTesthashu64Fnv1a builder testhashu64Fnv1a;
        addTestarrayofbools builder testarrayofbools;
        addTestf builder testf;
        addTestf2 builder testf2;
        addTestf3 builder testf3;
        addTestarrayofstring2 builder testarrayofstring2;
        addTestarrayofsortedstruct builder testarrayofsortedstruct;
        addFlex builder flex;
        addTest5 builder test5;
        addVectorOfLongs builder vectorOfLongs;
        addVectorOfDoubles builder vectorOfDoubles;
        addParentNamespaceTest builder parentNamespaceTest;
        addVectorOfReferrables builder vectorOfReferrables;
        addSingleWeakReference builder singleWeakReference;
        addVectorOfWeakReferences builder vectorOfWeakReferences;
        addVectorOfStrongReferrables builder vectorOfStrongReferrables;
        addCoOwningReference builder coOwningReference;
        addVectorOfCoOwningReferences builder vectorOfCoOwningReferences;
        addNonOwningReference builder nonOwningReference;
        addVectorOfNonOwningReferences builder vectorOfNonOwningReferences;
        addAnyUniqueType builder anyUniqueType;
        addAnyUnique builder anyUnique;
        addAnyAmbiguousType builder anyAmbiguousType;
        addAnyAmbiguous builder anyAmbiguous;
        addVectorOfEnums builder vectorOfEnums;
        addSignedEnum builder signedEnum;
        addTestrequirednestedflatbuffer builder testrequirednestedflatbuffer;
        addScalarKeySortedTables builder scalarKeySortedTables;
        end_ builder
end

end (* Example *)
module Example2 = struct

module Monster = struct
    type t

    type offset = t ByteBuffer.offset

    let init b pos : offset = ByteBuffer.offset b pos

    let of_union o : offset = ByteBuffer.offset_of_union o

    let getRootAsMonster b =
        let offset = (ByteBuffer.read_ocaml_int32 b (ByteBuffer.position b)) + (ByteBuffer.position b) in
        init b offset

    let start builder =
        Builder.startObject  builder 0

    let end_ builder =
        Builder.endObject builder


    let create ~builder=
        start builder;
        end_ builder
end

end (* Example2 *)
end (* MyGame *)

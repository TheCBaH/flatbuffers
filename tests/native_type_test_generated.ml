(* automatically generated by the FlatBuffers compiler, do not modify *)

open FlatBuffers

module Geometry = struct

module Vector3DAlt = struct
    type t    type offset = {b: ByteBuffer.t; pos: t ByteBuffer.offset}

    let init b pos = {b;pos}

    let of_union b pos = {b=b; pos=ByteBuffer.offset_of_union pos}

    (* Vector3DAlt *)
    let a (t:offset) =
        let offset = t.pos + 0 in
        ByteBuffer.readFloat32 t.b offset

    (* Vector3DAlt *)
    let b (t:offset) =
        let offset = t.pos + 4 in
        ByteBuffer.readFloat32 t.b offset

    (* Vector3DAlt *)
    let c (t:offset) =
        let offset = t.pos + 8 in
        ByteBuffer.readFloat32 t.b offset


    let create ~builder ~a ~b ~c =
        Builder.prep builder ~additional_bytes:4 12;
        Builder.addFloat32 builder c;
        Builder.addFloat32 builder b;
        Builder.addFloat32 builder a;
        Builder.offset builder
end

module Vector3D = struct
    type t    type offset = {b: ByteBuffer.t; pos: t ByteBuffer.offset}

    let init b pos = {b;pos}

    let of_union b pos = {b=b; pos=ByteBuffer.offset_of_union pos}

    (* Vector3D *)
    let x (t:offset) =
        let offset = t.pos + 0 in
        ByteBuffer.readFloat32 t.b offset

    (* Vector3D *)
    let y (t:offset) =
        let offset = t.pos + 4 in
        ByteBuffer.readFloat32 t.b offset

    (* Vector3D *)
    let z (t:offset) =
        let offset = t.pos + 8 in
        ByteBuffer.readFloat32 t.b offset


    let create ~builder ~x ~y ~z =
        Builder.prep builder ~additional_bytes:4 12;
        Builder.addFloat32 builder z;
        Builder.addFloat32 builder y;
        Builder.addFloat32 builder x;
        Builder.offset builder
end

module ApplicationData = struct
    type t    type offset = {b: ByteBuffer.t; pos: t ByteBuffer.offset}

    let init b pos = {b;pos}

    let of_union b pos = {b=b; pos=ByteBuffer.offset_of_union pos}

    let getRootAsApplicationData b =
        let offset = (ByteBuffer.read_ocaml_int32 b (ByteBuffer.position b)) + (ByteBuffer.position b) in
        init b offset

    let vectorsLength (t:offset) =
        let offset = ByteBuffer.__offset t.b t.pos 4 in
        if(offset!=0) then ByteBuffer.__vector_len t.b (t.pos + offset)
        else 0

    let vectors (t:offset) index =
        let offset = ByteBuffer.__offset t.b t.pos 4 in
        if(offset!=0) then
            let index = index * 12 in
            let offset = (ByteBuffer.__vector t.b (t.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.b offset in
            Some (Vector3D.init t.b offset)
        else None

    let vectors_altLength (t:offset) =
        let offset = ByteBuffer.__offset t.b t.pos 6 in
        if(offset!=0) then ByteBuffer.__vector_len t.b (t.pos + offset)
        else 0

    let vectors_alt (t:offset) index =
        let offset = ByteBuffer.__offset t.b t.pos 6 in
        if(offset!=0) then
            let index = index * 12 in
            let offset = (ByteBuffer.__vector t.b (t.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.b offset in
            Some (Vector3DAlt.init t.b offset)
        else None

    let start builder =
        Builder.startObject  builder 2

    let addVectors builder vectors =
        Builder.addFieldOffset builder 0 vectors (0)

    let startApplicationDataVectors builder numElems =
        Builder.startVector builder 12 numElems 4

    let addVectorsAlt builder vectorsAlt =
        Builder.addFieldOffset builder 1 vectorsAlt (0)

    let startApplicationDataVectorsAlt builder numElems =
        Builder.startVector builder 12 numElems 4

    let end_ builder =
        Builder.endObject builder


    let create ~builder~vectors ~vectorsAlt =
        start builder;
        addVectors builder vectors;
        addVectorsAlt builder vectorsAlt;
        end_ builder
end

end (* Geometry *)

(* automatically generated by the FlatBuffers compiler, do not modify *)

open FlatBuffers

module Geometry = struct

module Vector3DAlt = struct
    type t = {b: ByteBuffer.t; pos: t ByteBuffer.offset}

    let init b pos = {b;pos}

    let of_union b pos = {b=b; pos=ByteBuffer.offset_of_union pos}

    (* Vector3DAlt *)
    let a t =
        let offset = t.pos + 0 in
        ByteBuffer.readFloat32 t.b offset

    (* Vector3DAlt *)
    let b t =
        let offset = t.pos + 4 in
        ByteBuffer.readFloat32 t.b offset

    (* Vector3DAlt *)
    let c t =
        let offset = t.pos + 8 in
        ByteBuffer.readFloat32 t.b offset


    let create ~builder ~a ~b ~c =
        Builder.prep builder ~additional_bytes:4 12;
        Builder.addFloat32 builder c;
        Builder.addFloat32 builder b;
        Builder.addFloat32 builder a;
        Builder.offset builder
end

module Vector3D = struct
    type t = {b: ByteBuffer.t; pos: t ByteBuffer.offset}

    let init b pos = {b;pos}

    let of_union b pos = {b=b; pos=ByteBuffer.offset_of_union pos}

    (* Vector3D *)
    let x t =
        let offset = t.pos + 0 in
        ByteBuffer.readFloat32 t.b offset

    (* Vector3D *)
    let y t =
        let offset = t.pos + 4 in
        ByteBuffer.readFloat32 t.b offset

    (* Vector3D *)
    let z t =
        let offset = t.pos + 8 in
        ByteBuffer.readFloat32 t.b offset


    let create ~builder ~x ~y ~z =
        Builder.prep builder ~additional_bytes:4 12;
        Builder.addFloat32 builder z;
        Builder.addFloat32 builder y;
        Builder.addFloat32 builder x;
        Builder.offset builder
end

module ApplicationData = struct
    type t = {b: ByteBuffer.t; pos: t ByteBuffer.offset}

    let init b pos = {b;pos}

    let of_union b pos = {b=b; pos=ByteBuffer.offset_of_union pos}

    let getRootAsApplicationData b =
        let offset = (ByteBuffer.read_ocaml_int32 b (ByteBuffer.position b)) + (ByteBuffer.position b) in
        init b offset

    let vectorsLength t =
        let offset = ByteBuffer.__offset t.b t.pos 4 in
        if(ByteBuffer.not_null offset) then ByteBuffer.__vector_len t.b (t.pos + offset)
        else ByteBuffer.null

    let vectors t index =
        let offset = ByteBuffer.__offset t.b t.pos 4 in
        if(ByteBuffer.not_null offset) then
            let index = index * 12 in
            let offset = (ByteBuffer.__vector t.b (t.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.b offset in
            Some (Vector3D.init t.b offset)
        else None

    let vectors_altLength t =
        let offset = ByteBuffer.__offset t.b t.pos 6 in
        if(ByteBuffer.not_null offset) then ByteBuffer.__vector_len t.b (t.pos + offset)
        else ByteBuffer.null

    let vectors_alt t index =
        let offset = ByteBuffer.__offset t.b t.pos 6 in
        if(ByteBuffer.not_null offset) then
            let index = index * 12 in
            let offset = (ByteBuffer.__vector t.b (t.pos + offset)) + index in
            let offset = ByteBuffer.__indirect t.b offset in
            Some (Vector3DAlt.init t.b offset)
        else None

    let start builder =
        Builder.startObject  builder 2

    let addVectors builder vectors =
        Builder.addFieldOffset builder 0 vectors (0)

    let startApplicationDataVectors builder numElems =
        Builder.startVector builder 12 numElems 4

    let addVectorsAlt builder vectorsAlt =
        Builder.addFieldOffset builder 1 vectorsAlt (0)

    let startApplicationDataVectorsAlt builder numElems =
        Builder.startVector builder 12 numElems 4

    let end_ builder =
        Builder.endObject builder


    let create ~builder~vectors ~vectorsAlt =
        start builder;
        addVectors builder vectors;
        addVectorsAlt builder vectorsAlt;
        end_ builder
end

end (* Geometry *)
